// BF++ interpreter
// Grammar:
// + inc current cell
// - dec current cell
// > move to next cell
// < move to previous cell
// , read current cell from stdin
// . print current cell as ASCII char
// : print current cell as number
// [ code ] while(mem[pc]) { code } 

fn main() {
    // let code1 = String::from("+++-------:++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.");
    // let code2 = String::from("++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.");
    let code3 = String::from(">+++++++++[<+++++++++++>-]<[>[-]>[-]<<[>+>+<<-]>>[<<+>>-]>>>
    [-]<<<+++++++++<[>>>+<<[>+>[-]<<-]>[<+>-]>[<<++++++++++>>>+<
    -]<<-<-]+++++++++>[<->-]>>+>[<[-]<<+>>>-]>[-]+<<[>+>-<<-]<<<
    [>>+>+<<<-]>>>[<<<+>>>-]>[<+>-]<<-[>[-]<[-]]>>+<[>[-]<-]<+++
    +++++[<++++++<++++++>>-]>>>[>+>+<<-]>>[<<+>>-]<[<<<<<.>>>>>-
    ]<<<<<<.>>[-]>[-]++++[<++++++++>-]<.>++++[<++++++++>-]<++.>+
    ++++[<+++++++++>-]<.><+++++..--------.-------.>>[>>+>+<<<-]>
    >>[<<<+>>>-]<[<<<<++++++++++++++.>>>>-]<<<<[-]>++++[<+++++++
    +>-]<.>+++++++++[<+++++++++>-]<--.---------.>+++++++[<------
    ---->-]<.>++++++[<+++++++++++>-]<.+++..+++++++++++++.>++++++
    ++[<---------->-]<--.>+++++++++[<+++++++++>-]<--.-.>++++++++
    [<---------->-]<++.>++++++++[<++++++++++>-]<++++.-----------
    -.---.>+++++++[<---------->-]<+.>++++++++[<+++++++++++>-]<-.
    >++[<----------->-]<.+++++++++++..>+++++++++[<---------->-]<
    -----.---.>>>[>+>+<<-]>>[<<+>>-]<[<<<<<.>>>>>-]<<<<<<.>>>+++
    +[<++++++>-]<--.>++++[<++++++++>-]<++.>+++++[<+++++++++>-]<.
    ><+++++..--------.-------.>>[>>+>+<<<-]>>>[<<<+>>>-]<[<<<<++
    ++++++++++++.>>>>-]<<<<[-]>++++[<++++++++>-]<.>+++++++++[<++
    +++++++>-]<--.---------.>+++++++[<---------->-]<.>++++++[<++
    +++++++++>-]<.+++..+++++++++++++.>++++++++++[<---------->-]<
    -.---.>+++++++[<++++++++++>-]<++++.+++++++++++++.++++++++++.
    ------.>+++++++[<---------->-]<+.>++++++++[<++++++++++>-]<-.
    -.---------.>+++++++[<---------->-]<+.>+++++++[<++++++++++>-
    ]<--.+++++++++++.++++++++.---------.>++++++++[<---------->-]
    <++.>+++++[<+++++++++++++>-]<.+++++++++++++.----------.>++++
    +++[<---------->-]<++.>++++++++[<++++++++++>-]<.>+++[<----->
    -]<.>+++[<++++++>-]<..>+++++++++[<--------->-]<--.>+++++++[<
    ++++++++++>-]<+++.+++++++++++.>++++++++[<----------->-]<++++
    .>+++++[<+++++++++++++>-]<.>+++[<++++++>-]<-.---.++++++.----
    ---.----------.>++++++++[<----------->-]<+.---.[-]<<<->[-]>[
    -]<<[>+>+<<-]>>[<<+>>-]>>>[-]<<<+++++++++<[>>>+<<[>+>[-]<<-]
    >[<+>-]>[<<++++++++++>>>+<-]<<-<-]+++++++++>[<->-]>>+>[<[-]<
    <+>>>-]>[-]+<<[>+>-<<-]<<<[>>+>+<<<-]>>>[<<<+>>>-]<>>[<+>-]<
    <-[>[-]<[-]]>>+<[>[-]<-]<++++++++[<++++++<++++++>>-]>>>[>+>+
    <<-]>>[<<+>>-]<[<<<<<.>>>>>-]<<<<<<.>>[-]>[-]++++[<++++++++>
    -]<.>++++[<++++++++>-]<++.>+++++[<+++++++++>-]<.><+++++..---
    -----.-------.>>[>>+>+<<<-]>>>[<<<+>>>-]<[<<<<++++++++++++++
    .>>>>-]<<<<[-]>++++[<++++++++>-]<.>+++++++++[<+++++++++>-]<-
    -.---------.>+++++++[<---------->-]<.>++++++[<+++++++++++>-]
    <.+++..+++++++++++++.>++++++++[<---------->-]<--.>+++++++++[
    <+++++++++>-]<--.-.>++++++++[<---------->-]<++.>++++++++[<++
    ++++++++>-]<++++.------------.---.>+++++++[<---------->-]<+.
    >++++++++[<+++++++++++>-]<-.>++[<----------->-]<.+++++++++++
    ..>+++++++++[<---------->-]<-----.---.+++.---.[-]<<<]");
    let code = code3;

    let mut mem = [0 as i8; 30000];
    let mut pc : usize = 0; // program counter
    let mut dc : usize = 0; // data counter
    let mut stack : Vec<usize> = Vec::new(); // stack of positions of loop beginnings
    while pc < code.len() {
        match code.chars().nth(pc).unwrap() {
            '+' => { mem[dc] += 1; },
            '-' => { mem[dc] -= 1; },
            '>' => {
                // println!("> {}", pc);
                dc += 1;
            },
            '<' => {
                // println!("<");
                dc -= 1;
                //println!("dc = {}", dc);
            },
            ',' => { println!("TODO"); },
            '.' => { print!("{}", mem[dc] as u8 as char); },
            ':' => { print!("{}", mem[dc]); },
            '[' => {
                let mut cnt = 0;
                let mut close_found = false;
                for j in pc..code.len() {
                    match code.chars().nth(j).unwrap() {
                        '[' => { cnt += 1; },
                        ']' => { if cnt > 0 {cnt -= 1;} else { panic!("unpaired brackets"); } },
                        _ => {}
                    }
                    if cnt == 0 { // we've found close brace
                        if mem[dc] != 0 { // if current cell is not zero then start loop
                            // println!("[ at pc = {}, j = {}", pc, j);
                            stack.push(pc + 1); // save loop's first command address
                            // println!("loop added {}", pc + 1)
                        } else { // skip loop
                            pc = j;
                        }
                        close_found = true;
                        break;
                    }
                }
                if !close_found { panic!("unpaired brackets"); }
            },
            ']' => {
                if !stack.is_empty() {
                    if mem[dc] != 0 {
                        // println!("mem[dc] = {}, dc = {}", mem[dc], dc);
                        pc = stack[stack.len() - 1]; // jump to loop beginning
                        continue; // for not to increment if after match
                    } else {
                        stack.pop().unwrap();
                        // println!("loop deleted");
                    }
                } else { panic!("Unexpected ] pc = {}", pc); }
             },
            _ => {}
        }
        pc += 1;
    }
}
